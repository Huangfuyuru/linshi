# 贪心算法

#### 一、基本概念

在对问题求解时，总是做出在当前看来是最好的选择。做出某种意义上的局部最优解。关键是**贪心策略**的选择，每一步对后面没有影响。

#### 二、买卖股票的最佳时机

> 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 示例 1:
>
> 输入: [3,3,5,0,0,3,1,4]
> 输出: 6
> 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

问题：最大利润

策略一：从最低点买入，在最高点卖出。(追求单次利益)

策略二：从低点买入，只要可以赚钱就卖出；不断买卖。(追求多次利益)

策略三：从低点买入，到价格最高点 卖出，不断买卖。(在保证单次利益的基础上，实现多次交易)

我们采取策略三！

```javascript
let countBig = (prices)=>{
    let count = 0;
    for(let i=0,len=prices.length;i<len;i++){
        for(let j=i;j<len-1;j++){
            if(prices[j+1]>prices[j]){
                count+=prices[j+1]-prices[j];
                i=j
            }else{
                i=j
                break
            }
        }
    }
    return count;
}
console.log(countBig([3,3,5,0,0,3,1,4]))  //8
```



#### 三、柠檬水找零

> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
>
> 示例 1：
>
> 输入：[5,5,5,10,20]
> 输出：true
> 解释：
> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
> 由于所有客户都得到了正确的找零，所以我们输出 true。

问题：找零钱

策略一：给钱找零，不区分金额直到找到足够的零钱 (追求单次找零)

策略二：给钱找零，优先给金额大的零钱，尽量把零钱放到手里 (追求多次找零)

我们选择策略二

```javascript
  let countBig = (input)=>{
        //表示自己的钱箱，用于存储零钱
        let hand = [];

        //判断是否有顾客还在
        while(input.length){
            //取出当前排在最前面顾客的钱
            let money = input.shift();
            //这种情况不需要找零钱
            if(money === 5){
                hand.push(money)
            }else{
                //手里的零钱降序排列，钱数大的在前
                hand.sort((a,b)=>b-a);
                //需要找的零钱
                let change = money-5;
                for(let i=0,len=hand.length;i<len;i++){
                    if(hand[i]<=change){
                        change-=hand[i];
                        hand.splice(i,1);
                        //删除了元素，数组的长度发生了变化，要维持刚才的i不变
                        i--;
                    }
                    if(change === 0){
                        break
                    }
                }
                //没有足够的钱找给顾客
                if(change !== 0){
                    return false
                }else{
                    //顾客的钱收起来
                    hand.push(money)
                }
            }
        }
        return true;
    }
    console.log(countBig([5,5,10,10,20])) //false
```

