# 设计模式

## 单例模式

##### 定义

保证一个类仅有一个实例，并提供一个访问他的全局访问点。

方法一：缺点---不透明，

```javascript
 class SingleObject{
     login(){
         console.log('login...')
     }
 }
SingleObject.getInstance = (function(){
    let instance;
    return function(){
        if(!instance){
            instance = new SingleObject()
        }
        return instance
    }
})()
let obj1 = SingleObject.getInstance();
let obj2 = SingleObject.getInstance();
console.log(obj1 === obj2)
```

```java
var getSingle = function(fn){
        var result;
        return function(){
            return result || (result = fn.apply(this,arguments))
        }
    }
    var createLoginLayer = function(){
        var div = document.createElement('div');
        div.innerHTML = '我是登陆浮窗';
        div.style.display = 'none';
        document.body.appendChild(div);
        return div;
    }
    var createIframe = function(){
        var div = document.createElement('iframe');
        document.body.appendChild(div);
        return div;
    }
    var createSingleLoginLayer = getSingle(createLoginLayer);
    var createIframeBtn = getSingle(createIframe)
    document.getElementById('loginBtn').onclick = function(){
        var loginLayer = createSingleLoginLayer();
        loginLayer.style.display = 'block'
    }
    document.getElementById('iframeBtn').onclick = function(){
        var ifi = createIframeBtn();
        ifi.src = 'https://www.baidu.com/'
    }
```

因为是单例，所以我们不应该单独建一个类，然后只让这个类有一个实例。所以不要采用建类这种方式。

```javascript
var getSingle = function(fn){
        var result;
        return function(){
            return result || (result = fn.apply(this,arguments))
        }
    }
    var createLoginLayer = function(){
        var div = document.createElement('div');
        div.innerHTML = '我是登陆浮窗';
        div.style.display = 'none';
        document.body.appendChild(div);
        return div;
    }
    var createIframe = function(){
        var div = document.createElement('iframe');
        document.body.appendChild(div);
        return div;
    }
    var createSingleLoginLayer = getSingle(createLoginLayer);
    var createIframeBtn = getSingle(createIframe)
    document.getElementById('loginBtn').onclick = function(){
        var loginLayer = createSingleLoginLayer();
        loginLayer.style.display = 'block'
    }
    document.getElementById('iframeBtn').onclick = function(){
        var ifi = createIframeBtn();
        ifi.src = 'https://www.baidu.com/'
    }
```



## 策略模式

##### 定义

定义一系列的算法，把他们一个个封装起来，并且使他们可以互相替换。一个策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类，环境类接受客户的请求，随后把请求委托给某一个策略类。

验证表单

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <form action="#" id="registerForm" method="post">
        请输入用户名:<input type="text" name="UserName"/>
        请输入密码:<input type="text" name="password"/>
        请输入手机号码:<input type="text" name="phoneNumber"/>
        <button>提交</button>
    </form>
</body>
<script>
    var registerForm = document.getElementById('registerForm');
    registerForm.onsubmit = function(e){
        var errorMsg = validataFunc();
        if(errorMsg){
            alert(errorMsg);
            return false;
        }
    }
    var strategies = {
        "ifNonEmpty":function(value,errorMsg){
            if(value === ''){
                return errorMsg
            }
        },
        "minLength":function(value,length,errorMsg){
            if(value.length<length){
                return errorMsg
            }
        },
        "isMobile":function(value,errorMsg){
            if(!/(^1[3|5|8][0-9]{9}$)/.test(value)){
                return errorMsg
            }
        }
    }
    var validataFunc = function(){
        var validator = new Validator();
        validator.add(registerForm.UserName,'ifNonEmpty','用户名不能为空')
        validator.add(registerForm.password,'minLength:6','密码长度不能少于6位')
        validator.add(registerForm.phoneNumber,'isMobile','手机号码格式不正确')
        var errorMsg = validator.start();
        return errorMsg;
    }
   
    class Validator{
        constructor(){
            this.cache = []
        }
        add(dom,rule,errorMsg){
            var ary = rule.split(':');
            this.cache.push(function(){
                var strategy = ary.shift();
                ary.unshift(dom.value);
                ary.push(errorMsg);
                return strategies[strategy].apply(dom,ary)

            })
        }
        start(){
            for(var i=0,validatorFunc;validatorFunc=this.cache[i++];){
                var msg = validatorFunc();
                if(msg){
                    return msg
                }
            }
        }
    }
    
</script>
</html>
```



## 代理模式

## 迭代器模式

## 发布-订阅模式

##### 定义

发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

##### 实现步骤

1. 首先要指定好谁充当发布者。
2. 然后给发布者添加一个缓存列表，用于存放回调函数以通知订阅者
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。

